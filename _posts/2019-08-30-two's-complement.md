---
layout: post
title:  "补码探究"
date:   2019-08-30 14:14:54
categories: Computer_basic
tags:  two's_complement
---

* content
{:toc}

最近做算法题，对补码产生了兴趣，简单写写。



### 一、定义

原码就是机器数，是加了一位符号位的二进制数，正数符号位为0，负数符号位为1

反码，英语里又叫ones' complement（对1求补），这里的1，本质上是一个有限位计数系统里所能表示出的最大值。求反又被称为对一求补，用最大数减去一个数就能得到它的反码，很容易看出在二进制里11111111减去任何数结果都是把这个数按位取反，0变1，1变零，所以才称之为反码。

补码，英语里又叫two's complement（对2求补），这个2指的是计数系统的容量（模），就是计数系统所能表示的状态数（容量等于最大数加一，因为多容纳了一个表示即0）。对7位二进制数来说容量就是10000000，这个模是不可能取到的，因为位数多一位。10000000=1111111+1，所以（10000000－1010010）稍加改变就成了（1111111－1010010）+1，所以补码又可以表述为先求反再加1。**易知补码的补码是本身**


### 二、有限容量的计数系统与补数
补数：`x%系统容量` 和 `y%系统容量` 相等，则x与y互为补数；或者换一种表述，x和y相差为n倍系统容量时，x与y互为补数。比如在模=12时，{…, -7, 5, 17, 29, …}两两之间互为补数。（这里的补数概念是我为了方便表述补码，自己定义的概念）

对同一计数系统中的数量可以定义运算如加减，但运算结果超出预设位数时，就要发生溢出，这个溢出其实就是模，是时钟的一整圈（因此丢掉它没有影响），如果进位没有被另一个计数系统接受，结果看似“失真”，本质上是进入了“第二次循环”。

![](https://raw.githubusercontent.com/GinSoda/Storage_Public/master/2019-08-30-1.jpg)

以时钟系统为例，8+7=15=13(十二进制)。进位丢失，表盘上只显示3。而8+(-5)也可以表示为3，这就说明在有限容量的计数系统中，+7和-5是完全相同的，而5和-7正是关于模12的一对补数。

所以不考虑进位时，在有限容量的计数系统中，对一对补数进行加法，结果是一样的。所以通过引入补数，把减正数（x-5）==> 加负数（x+(-5)）==> 加负数的补数（x+7）

### 三、求补码与求补数

#### 1
一般求补数，直接x加n倍系统容量或n倍减系统容量，得到x的补数

求补码是求补数的一种特殊情况：系统容量减去当前数，然后正负号取反。这是由于这一特性：**当x和y互为补数，且x × y<0时，x的绝对值加y的绝对值等于系统容量。**

负数求补码是求补码里面的一种特殊情况：定义中符号位不参与运算，是因为负数符号位本来就是1和正数相对。

#### 2
为什么计算机中负数求补码、正数求补码都和求补码定义不一样？这是因为取值范围受限。

比如-1的原码数值位代表1，所以模减去1等于 负一加模 等于 0b1111 1111，可以表示{…, -257, -1, 255, 511, …}中任何一个数，只有-1在系统取值范围[-128, 127]内，所以0b1111 1111代表-1。

同理正数的补码是本身，是因为，以2为例0b0000 0010可以表示{…, -254, 2, 258, 514, …}，只有2在系统取值范围[-128, 127]内，所以0b0000 0010代表2。

**这里负数求补码、正数求补码中`求补码`三个字不是求补数，而是一种映射，将`二进制表示`映射到`系统数字的表示范围`(如下图红线所示)。**

![](https://raw.githubusercontent.com/GinSoda/Storage_Public/master/2019-08-30-2.jpg)	

#### 3
~x+1 本质是求-x的补数，对int来说效果是符号取反

### 四、符号位
- 符号位不参与反码、补码运算

- 符号位参与加法和减法运算

- 符号位参与 与、或、非和异或 运算

- 符号位的左移右移：c++中负数不能左移，负数右移高位填充1; -1>>1还是-1，1>>1能得到0
	
![](https://raw.githubusercontent.com/GinSoda/Storage_Public/master/2019-08-30-3.jpg)
	
在容量=256的系统中，-1和255互为补数，所以两者二进制表示相同，都为0b1111 1111。实际上容量=256的系统中0b1111 1111可以表示{…, -257, -1, 255, 511, …}中任何一个数。
### 五、使用补码的原因

数字逻辑电路只能做加法（做减法很慢，或者说电路设计上同时实现加法和减法比较复杂）。

所以，引入补码，把减操作分解成了 求补码和加法 两步操作。比如模12的系统：减正数（x-5）==> 加负数（x+(-5)）==> 加负数的补数（x+7）

对于8位二进制系统，未引入补码时，只能做0到255内的加法运算；引入补码后，可以实现0到127的加法和0到128的减法，注意，不能实现+129也不能实现-129.

为什么要使用补码？因为要克服原码做加减法的困难，把减法变成加法，使符号位参与运算。出于上述问题才把模的概念引入，引入模的思想是为了符号位运算服务，而不是因为使用了模而硬造了个符号位。
### 参考目录

https://www.zhihu.com/question/23172611/answer/119406298